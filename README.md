# MMFPractice

## Рекурсия (22)
<img width="1185" height="344" alt="image" src="https://github.com/user-attachments/assets/4396d9dd-a377-402d-a227-6dcca49e273a" />

## Односвязный список (12)
Дан односвязный список, заполненный случайными числами, формирующими неубывающую последовательность, и каждый узел этого списка является начальным для некоторого другого списка произвольной (небольшой) длины
Эти дополнительные списки также односвязны, а их элементы – упорядочены по неубыванию
Т.о., у каждого узла есть два указателя – на следующий в основном списке и на «нижний» в дополнительном
Нужно «сплющить» эту структуру, сохраняя упорядоченность
<img width="810" height="378" alt="image" src="https://github.com/user-attachments/assets/3a3a035a-6382-47c5-9a0b-ca414fc0c7a1" />


## Очередь на одном и двух стеках (11)
Реализуйте структуру данных «Очередь», взяв за основу два стека (в первом реализовано помещение в очередь, во втором – выход из нее)
Сравните эффективность полученной реализации с очередью на одном стеке

## Бинарное дерево поиска (кратчайший путь) (12)
Поле, представленное как прямоугольная матрица, размерность которой пользователь вводит в реальном времени, показывает заминированный участок (мина обозначается как +, а безопасный участок – как 0). Мин на поле – произвольное количество (к счастью, все они заметны)
Требуется найти путь наименьшей длины между двумя введенными ячейками. Предусмотреть ограничения на ввод:
- ячейки должны принадлежать кайме матрицы
- начинать в ячейке, где находится мина, нельзя
Ходить по ячейкам, смежным слева, справа, снизу и сверху с минами нельзя

## Бинарный поиск (проверка рандомайзера) (9)
Антон написал свой генератор случайных чисел и просит Бориса проверить, хорошо ли тот работает. Для этого Антон присылает ему массив из N сгенерированных чисел, и два целых числа – X и Y. Если в массиве не меньше X чисел из промежутка [E-Y; E+Y] для любого целого E, тогда генератор нуждается в доработке
Борис просит Вас автоматизировать проверку, используя бинарный поиск

